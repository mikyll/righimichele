<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
   
<title>RadarSystem22</title></head>
    
<body>
<div id="top">
<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
 Primo progetto. 
 
 
<h2>Requirements</h2>

 
<div class="remark">
 
	Si desidera costruire un’applicazione software capace di:
	<ul>
	<li>(requisito <b>radarGui</b>) mostrare le distanze rilevate da un sensore Sonar <tt>HC-SR04</tt>
	 connesso a un RaspberryPi su un display (RadarDisplay) a forma di radar connesso a un PC.

	<center><img src="img/radarDisplay.png" width="10%"></img></center>
	<li>(requisito <b>ledAlarm</b>) accendere un Led se la distanza rilevata dal Sonar 
	è inferiore a un valore limite prefissato denominato <tt>DLIMIT</tt>.
	</li> 
</div>

<h2>Problem analysis</h2>
 

<h2>Test plans</h2> 
<div class="remark">
	<ol>
		<li>
		Verificare che l'oggetto venga rilevato correttamente:
		utilizzare un metro per misurare la distanza dell'oggetto dal sonar, e verificare che la distanza rilevata sia circa la medesima o comunque differisca di un errore trascurabile;
		</li>
		<li>
		Verificare che il LED si accenda quando l'oggetto viene posizionato ad una distanza inferiore alla soglia <tt>DLIMIT</tt>;
		</li>
		<li>
		Verificare che radarGui aggiorni correttamente la grafica del radar e le coordinate dell'oggetto rilevato, utilizzando un client di test che invii valori pseudo-randomici o una sequenza fissa;
		</li>
	</ol>
</div>

<h2>Project</h2>
<a href="https://github.com/mikyll/righimichele/tree/master/iss2022/RadarSystem22">Repository del progetto</a>
<table>
	<tr align="center">
		<td><a href="https://github.com/mikyll/righimichele/tree/master/iss2022/RadarSystem22/radarClient/src"><img width="93%" src="img/radarClient.gif"/></a></td>
		<td><a href="https://github.com/mikyll/righimichele/tree/master/iss2022/RadarSystem22/radarGUI"><img width="99%" src="img/radarGUI.gif"/></a></td>
	</tr>
	<tr align="center">
		<td>Radar Client (Sonar)</td>
		<td>Radar Server (GUI)</td>
	</tr>
</table>
<div class="remark">
<h3>Architettura Logica</h3>
Il progetto consiste in 2 princiali componenti:
<ul>
	<li><b>server</b>,
	esegue su una macchina distinta rispetto al raspberry e si occupa di <ins>ricevere i dati inviati dal raspberry</ins>, elaborarli e <ins>visualizzarli a schermo</ins> tramite la grafica di un radar.
	</li>
	<li><b>client</b>,
	esegue sul raspberry e si occupa di <ins>ricevere l'input dal sonar</ins> e <ins>trasmetterlo al server</ins>. Sempre il client, qualora la distanza rilevata dal sonar dovesse essere inferiore alla soglia <tt>DLIM</tt>, si occupa di <ins>accendere il LED</ins>.
	</li>
</ul>

<h3>Strumenti e Librerie</h3>
Per la realizzazione del radar abbiamo scelto di utilizzare la libreria <b><a href="https://www.libsdl.org/download-2.0.php">SDL2</a></b>, che permette di realizzare applicazioni grafiche efficienti ed è molto portabile (lo stesso codice SDL2 può essere compilato ed eseguito su architetture differenti). SDL2 prevede anche un modulo relativo al networking, che abbiamo deciso di utilizzare per la comunicazione tra il raspberry e la macchina che visualizza graficamente i risultati. Per la realizzazione del codice che esegue su raspberry, abbiamo deciso di utilizzare la libreria <b><a href="http://wiringpi.com/">wiringPi</a></b>, che permette di accedere facilmente all'hardware e in particolare ai pin GPIO.

<h3>Dettagli Realizzativi</h3>
<h4>Server</h4>
Il server è costituito da diversi moduli, ciascuno dei quali ha un ruolo differente:
<ul>
	<li><b><a href="https://github.com/mikyll/righimichele/blob/master/iss2022/RadarSystem22/radarGUI/src/main.c">main.c</a></b>,
	inizializza SDL2 e le varie strutture dati, dopodiché implementa il ciclo di esecuzione principale dell'applicazione, realizzando la sequenza logica delle operazioni da eseguire ad ogni frame: quando la linea di rilevazione del radar si trova ad un angolo che corrisponde ad una direzione associata ad un sonar, controlla se ci sono dati da ricevere dal client relativo; in caso affermativo mostra a schermo un pallino, la cui distanza dal centro del radar è proporzionale alla distanza rilevata dal sonar; dopodiché viene aggiornata la posizione della linea del radar, applicandovi una rotazione in base al centro di quest'ultimo; infine, viene cappato il framerate per fare in modo che la linea compia un giro completo (360°) ogni 2 secondi.
	</li>
	<li><b><a href="https://github.com/mikyll/righimichele/blob/master/iss2022/RadarSystem22/radarGUI/src/draw.c">draw.c</a></b>,
	contiene tutte le funzioni utili a renderizzare una texture nella finestra mostrata a schermo, e disegnare le varie entità presenti. In particolare la funzione <code>prepareScene()</code> pulisce il renderer, cancellando tutto ciò che era presente dal frame precedente, così che la finestra possa essere ridisegnata con texture ed entità aggiornate. La funzione <code>presentScene()</code> visualizza il contenuto del renderer a schermo. Queste due procedure vengono chiamate rispettivamente all'inizio ed alla fine del ciclo del main.
	</li>
	<li><b><a href="https://github.com/mikyll/righimichele/blob/master/iss2022/RadarSystem22/radarGUI/src/text.c">text.c</a></b>,
	contiene le funzioni che permettono di renderizzare del testo. Lo scopo di tale modulo è quello di consentire di visualizzare a schermo le coordinate degli oggetti rilevati, oltre alla rappresentazione grafica del pallino nel radar.
	</li>
	<li><b><a href="https://github.com/mikyll/righimichele/blob/master/iss2022/RadarSystem22/radarGUI/src/net.c">net.c</a></b>,
	contiene tutte le funzioni e procedure che permettono la comunicazione tra raspberry e server del radar. In particolare, utilizziamo un set di socket che ci permette di controllare se sono presenti messaggi nelle socket contenutevi e, in caso affermativo, di leggere il pacchetto in arrivo. Questo permette di realizzare un meccanismo di comunicazione ideale, superando la semantica sincrona della receive. Tuttavia, poiché il client esegue su una macchina separata, e i tempi non sono sincronizzati, abbiamo utilizzato un segnale di ACK, inviato dal server al client, per fare in modo che il client non invii più pacchetti di quanti il server ne possa ricevere. Se così non fosse, questi si accumulerebbero e non rappresenterebbero più (quando viene mostrato a schermo sul radar) lo stato attuale rilevato dal sonar. In questo modo, il client attende l'ACK prima di fare una nuova rilevazione.
	</li>
	
</ul>
<h5>Extra</h5>
Per rendere l'applicazione più gradevole, abbiamo deciso di aggiungere ulteriori componenti:
<ul>
	<li><b><a href="https://github.com/mikyll/righimichele/blob/master/iss2022/RadarSystem22/radarGUI/src/sound.c">sound.c</a></b>,
	il modulo sound permette sostanzialmente di riprodurre un suono quando viene rilevato un oggetto, nel range del sonar.
	</li>
</ul>

<h4>Client</h4>
Per realizzare il componente client, abbiamo utilizzato il codice realizzato in precedenza per <a href="https://github.com/mikyll/righimichele/blob/master/iss2022/RadarSystem22/ledAlarm/src/ledAlarm.c">ledAlarm</a>, il quale permetteva di ottenere la distanza rilevata dal sonar e di accendere il LED se questa era inferiore ad una certa soglia. Dunque lo abbiamo modificato aggiungendo le funzionalità relative alla comunicazione col server (radarGUI), ovvero il client ad ogni ciclo:
<ul>
	<li>
		rileva la presenza di oggetti tramite il sonar, scrivendo il valore HIGH sul pin TRIGGER, controllando la durata in cui l'onda del pin ECHO rimane a valore HIGH, e facendo qualche piccolo calcolo per ottenere la distanza;
	</li>
	<li>
		invia al server la distanza rilevata, sfruttando la libreria SDL2_net;
	</li>
	<li>
		attende l'ACK del server, prima di effettuare una nuova rilevazione.
	</li>
</ul>
Per maggiori informazioni sul funzionamento del sonar, consultare <a href="https://github.com/mikyll/righimichele/tree/master/iss2022/RadarSystem">questo README</a>.

<h3>Collegamenti</h3>
<img width="70%" src="img/ledAlarm circuit.png"/>
</div>

<h2>Testing</h2> 
 

<h2>Deployment</h2> 

 
<h2>Maintenance</h2> 
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div float="left" style="width: 80%; background-color: rgba(86, 56, 253, 0.9);color:white;font-family: Tahoma;">
	<p style="float: left; width: 60%; padding: 10px">
		By <b>Michele Righi</b><br/><br/>
		<span><b>ISS repo: <a id="issRepo" style="color:white" href="https://github.com/mikyll/righimichele/tree/master/iss2022">mikyll/righimichele/iss2022/</a></b></span><br/><br/>
		Contacts:<br/>
		e-mail: michele.righi5@studio.unibo.it<br/>
		GitHub: <a id="github" style="color:white" href="https://github.com/mikyll">mikyll</a><br/>
		LinkedIn: <a id="issRepo" style="color:white" href="https://www.linkedin.com/in/michele-righi/">Michele Righi</a><br/>
	</p>
	<img src="./img/Michele Righi avatar.png" alt="Michele Avatar" width="30%" height="30%"/>
</div>
<img  style="float: right; border: none; padding-bottom: 10px; padding-right: 10px" src="./img/NoWarUkraineDoveColored.png" alt="No War Ukraine" width="5%" height="5%"/>

</body>
</html>